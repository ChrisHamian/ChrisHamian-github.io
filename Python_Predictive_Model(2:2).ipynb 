{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#########################################################\n",
    "# IMPORTS NECESSARY FOR THE SCRIPT           \n",
    "#########################################################\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import time\n",
    "import datetime\n",
    "from datetime import timedelta\n",
    "import statistics\n",
    "import matplotlib.pyplot as plt\n",
    "import random\n",
    "import os\n",
    "import math\n",
    "from dateutil.relativedelta import relativedelta"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [],
   "source": [
    "############################################################\n",
    "# UNCOMMENT THE CODE BELOW IF YOU WANT TO USE TRAINER STATS           \n",
    "############################################################\n",
    "la_filter = 'TRAINER'\n",
    "la_filter_length = pd.read_csv('LA-trainers.csv')\n",
    "la_filter_length = len(la_filter_length)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# ###########################################################\n",
    "# # # UNCOMMENT THE CODE BELOW IF YOU WANT TO USE TIMESLOT STATS           \n",
    "# ###########################################################\n",
    "# la_filter = 'TIMESLOT'\n",
    "# la_filter_length = pd.read_csv('LA-timeslots.csv')\n",
    "# la_filter_length = len(la_filter_length)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "############################################################\n",
    "# UNCOMMENT THE CODE BELOW IF YOU WANT TO USE TOTAL DATASET           \n",
    "############################################################\n",
    "la_stats_filter = pd.read_csv('LA-stats('+ la_filter +')(TOTAL).csv')      #### READS WHICH FILTER YOU CHOSE\n",
    "la_stats_monthly = pd.read_csv('LA-monthly-stats(TOTAL).csv')      #### READS WHICH DATASET YOU CHOSE\n",
    "paid = 0\n",
    "\n",
    "with open(\"monthly_first_timers_LA(TOTAL).txt\", \"r\") as f:      ##### READS THE NUMBER OF MONTHLY FIRST TIMERS \n",
    "    customers_text = f.read()                                ##### STORES IN ARRAY: FIRST_TIMERS_MONTHLY\n",
    "    first_timers_monthly = [ float(x) for x in customers_text.split() ]\n",
    "with open(\"actual_monthly_count_LA(TOTAL).txt\", \"r\") as f:\n",
    "    customers_text = f.read()                         #### READS THE ACTUAL NUMBER OF MONTHLY CUSTOMERS AND STORES IN ARRAY: ACTUAL_MONTHLY_COUNT\n",
    "    actual_monthly_count = [ float(x) for x in customers_text.split() ]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# ############################################################\n",
    "# # UNCOMMENT THE CODE BELOW IF YOU WANT TO USE PAID DATASET           \n",
    "# ############################################################\n",
    "# la_stats_filter = pd.read_csv('LA-stats('+ la_filter +')(PAID).csv')      #### READS WHICH FILTER YOU CHOSE\n",
    "# la_stats_monthly = pd.read_csv('LA-monthly-stats(PAID).csv')      #### READS WHICH DATASET YOU CHOSE\n",
    "# paid = 1\n",
    "# with open(\"monthly_first_timers_LA(PAID).txt\", \"r\") as f:      ##### READS THE NUMBER OF MONTHLY FIRST TIMERS \n",
    "#     customers_text = f.read()                                ##### STORES IN ARRAY: FIRST_TIMERS_MONTHLY\n",
    "#     first_timers_monthly = [ float(x) for x in customers_text.split() ]\n",
    "# with open(\"actual_monthly_count_LA(PAID).txt\", \"r\") as f:\n",
    "#     customers_text = f.read()                         #### READS THE ACTUAL NUMBER OF MONTHLY CUSTOMERS AND STORES IN ARRAY: ACTUAL_MONTHLY_COUNT\n",
    "#     actual_monthly_count = [ float(x) for x in customers_text.split() ]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "############################################################\n",
    "# TRANSFERS INFO FROM CSV FILE TO ARRAYS BY COLUMNS\n",
    "# SHOULD NOT NEED TO TOUCH THIS CODE BLOCK\n",
    "############################################################\n",
    "group_1_percent_filter = la_stats_filter[\"CUSTOMER GROUP 1%\"]#### PERCENTAGE OF GROUP 1 CLASS. PEOPLE USING MONTHLY-FILTER-STATS\n",
    "group_2_percent_filter = la_stats_filter[\"CUSTOMER GROUP 2%\"]#### PERCENTAGE OF GROUP 2 CLASS. PEOPLE USING MONTHLY-FILTER-STATS\n",
    "group_3_percent_filter = la_stats_filter[\"CUSTOMER GROUP 3%\"]#### PERCENTAGE OF GROUP 3 CLASS. PEOPLE USING MONTHLY-FILTER-STATS\n",
    "group_4_percent_filter = la_stats_filter[\"CUSTOMER GROUP 4+%\"]#### PERCENTAGE OF GROUP 4+ CLASS. PEOPLE USING MONTHLY-FILTER-STATS\n",
    "group_2_avg_days_filter = la_stats_filter[\"AVG TIME 2 CLASSES\"]#### AVERAGE DAYS BETWEEN 2 CLASSES. PEOPLE USING MONTHLY-FILTER-STATS\n",
    "group_3_avg_days_filter = la_stats_filter[\"AVG TIME 3 CLASSES\"]#### AVERAGE DAYS BETWEEN 3 CLASSES. PEOPLE USING MONTHLY-FILTER-STATS\n",
    "group_4_avg_days_filter = la_stats_filter[\"AVG TIME 4+ CLASSES\"]#### AVERAGE DAYS BETWEEN 4+ CLASSES. PEOPLE USING MONTHLY-FILTER-STATS\n",
    "group_4_avg_classes_filter = la_stats_filter[\"AVG NUMBER 4+ CLASSES\"]#### AVERAGE # OF 4+ CLASSES USING MONTHLY-FILTER-STAT\n",
    "filter_percent = la_stats_filter[la_filter + ' Percent'] #### FILTER PERCENT FOR MONTHLY-FILTER STATS\n",
    "############################################################\n",
    "# TRANSFERS INFO FROM CSV FILE TO ARRAYS BY COLUMNS\n",
    "# SHOULD NOT NEED TO TOUCH THIS CODE BLOCK\n",
    "############################################################\n",
    "group_1_percent_month = la_stats_monthly[\"CUSTOMER GROUP 1%\"]\n",
    "group_2_percent_month = la_stats_monthly[\"CUSTOMER GROUP 2%\"]\n",
    "group_3_percent_month = la_stats_monthly[\"CUSTOMER GROUP 3%\"]\n",
    "group_4_percent_month = la_stats_monthly[\"CUSTOMER GROUP 4+%\"] \n",
    "group_2_avg_days_month = la_stats_monthly[\"AVG TIME 2 CLASSES\"]\n",
    "group_3_avg_days_month = la_stats_monthly[\"AVG TIME 3 CLASSES\"]\n",
    "group_4_avg_days_month = la_stats_monthly[\"AVG TIME 4+ CLASSES\"]\n",
    "group_4_avg_classes_month = la_stats_monthly[\"AVG NUMBER 4+ CLASSES\"]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "############################################################\n",
    "# GENERATES THE DATES FROM THE MONTHLY FIRST TIMERS\n",
    "# USING **MONTHLY-FILTER** STATS\n",
    "############################################################\n",
    "last_full_month=len(actual_monthly_count)-2   #### THIS KEEPS TRACK OF THE LAST FULL MONTH OF DATA, FOR GRAPHING PURPOSES\n",
    "start_date = datetime.datetime.strptime('2018-07-10', '%Y-%m-%d')     ##### START DATE OF THAT REGION\n",
    "current_month=0                                                              ##### SETS CURRENT MONTH TO ZERO\n",
    "total_months = len(group_4_avg_classes_filter)                              ##### STORES TOTAL MONTHS REGION HAS BEEN OPEN\n",
    "group_num_classes = [1, 2, 3, 0]            ##### ARRAY OF CLASSES FOR EACH GROUP CLASSIFICATION, 4+ GROUP IS DETERMINED IN THE LOOP\n",
    "date_array_filter = []                             ##### ARRAY THAT WILL STORE ALL THE GENERATED DATES\n",
    "cust_group_ctr = [None]*4                   ##### 2D ARRAY OF THE PERCENTAGE OF EACH GROUP CLASSIFICATION BY MONTH-FILTER\n",
    "group_num_days = [None]*4                   ##### 2D ARRAY OF THE AVERAGE DAYS BETWEEN CLASSES FOR EACH GROUP CLASSIFICATION\n",
    "group_num_days[0] = 0                       ##### SETS FIRST INDEX TO ZERO BECAUSE THE 1ST GROUP ONLY CAME ONCE\n",
    "initial_month = 0                           ##### USED TO RESET THE MONTH DATE TO THE 1ST OF EVERY MONTH\n",
    "for cust_per_day in first_timers_monthly:    ##### ITERATING THROUGH LIST OF # OF CUSTOMERS PER MONTH\n",
    "    for monthly_filter in range(la_filter_length):          ##### ITERATING THROUGH EACH FILTER(EX. EACH TRAINER)\n",
    "        customers = cust_per_day*(filter_percent[(current_month*la_filter_length)+monthly_filter]) ### NUMBER OF CUSTOMERS FOR THAT GROUP(EX. NUMBER OF PEOPLE TAHT TOOK AJ'S CLASS IN JANUARY 2018)   \n",
    "        cust_group_ctr[0] = customers*group_1_percent_filter[(current_month*la_filter_length)+monthly_filter]  ### THAT NUMBER OF CUSTOMERS MULTIPLIED BY THE PERCENTAGE OF THAT CLASSIFICATION       \n",
    "        cust_group_ctr[1] = customers*group_2_percent_filter[(current_month*la_filter_length)+monthly_filter]  ### EX. THE NUMBER OF PEOPLE THAT STARTED WITH AJ'S CLASS AND TOOK 2 TOTAL CLASSES\n",
    "        cust_group_ctr[2] = customers*group_3_percent_filter[(current_month*la_filter_length)+monthly_filter]\n",
    "        cust_group_ctr[3] = customers*group_4_percent_filter[(current_month*la_filter_length)+monthly_filter]\n",
    "        group_num_days[3] = group_4_avg_days_filter[(current_month*la_filter_length)+monthly_filter]           #### AVERAGE DAYS FROM GROUP 2(CLASSES) CLASSIFICATON, TAKEN FROM THE CSV FILE\n",
    "        group_num_days[1] = group_2_avg_days_filter[(current_month*la_filter_length)+monthly_filter]           #### AVERAGE DAYS FROM GROUP 3(CLASSES) CLASSIFICATON, TAKEN FROM THE CSV FILE\n",
    "        group_num_days[2] = group_3_avg_days_filter[(current_month*la_filter_length)+monthly_filter]           #### AVERAGE DAYS FROM GROUP 4+(CLASSES) CLASSIFICATON, TAKEN FROM THE CSV FILE\n",
    "        group_num_classes[3] =  (group_4_avg_classes_filter[current_month])                            #### AVERAGE NUMBER OF 4+ CLASSES FOR THAT MONTHLY-FILTER CLASSIFICATION\n",
    "        \n",
    "        for y in range(0,4):\n",
    "            ####### CHANGE 'int' TO 'math.ceil' IF PROJECTIONS ARE LOW #######  \n",
    "            for z in range(1, math.ceil(cust_group_ctr[y])+1):                          #### LOOPS THROUGH THE NUMBER OF CUSTOMERS IN THAT GROUP CLASSIFICATION\n",
    "                ####### CHANGE 'int' TO 'math.ceil' IF PROJECTIONS ARE LOW #######  \n",
    "                for j in range(math.ceil(group_num_classes[y])+1):                        #### LOOPS THROUGH THE CURRENT CLASSES EX. 4+ CLASSES FOR AJ'S CLASS IN JANUARY 2018\n",
    "                    date = (start_date+timedelta(days=int(group_num_days[y])*j))        #### GENERATES DATES FOR CUSTOMERS DEPENDING ON THE GROUP \n",
    "                    date_array_filter.append(date)                                             #### ADDS NEW DATE TO DATE_ARRAY\n",
    "    current_month+=1                                          #### INCREMENTS CURRENT MONTH TO UPDATE THE MONTHLY STATS\n",
    "    if (initial_month==0):\n",
    "        start_date = start_date - timedelta(days=9)\n",
    "    initial_month = 1\n",
    "    start_date = start_date + relativedelta(months=1)    #### UPDATES THE DATE TO ACCOMODATE FOR THE NEXT MONTH"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "############################################################\n",
    "# GENERATES THE DATES FROM THE MONTHLY FIRST TIMERS\n",
    "# USING **MONTHLY** STATS\n",
    "############################################################\n",
    "\n",
    "start_date = datetime.datetime.strptime('2018-7-10', '%Y-%m-%d')     ##### START DATE OF THAT REGION\n",
    "current_month=0                                                              ##### SETS CURRENT MONTH TO ZERO\n",
    "#total_months = len(group_4_avg_classes)                              ##### STORES TOTAL MONTHS REGION HAS BEEN OPEN\n",
    "group_num_classes = [1, 2, 3, 0]            ##### ARRAY OF CLASSES FOR EACH GROUP CLASSIFICATION, 4+ GROUP IS DETERMINED IN THE LOOP\n",
    "date_array_month = []                             ##### ARRAY THAT WILL STORE ALL THE GENERATED DATES\n",
    "cust_group_ctr = [None]*4                   ##### 2D ARRAY OF THE PERCENTAGE OF EACH GROUP CLASSIFICATION BY MONTH-FILTER\n",
    "group_num_days = [None]*4                   ##### 2D ARRAY OF THE AVERAGE DAYS BETWEEN CLASSES FOR EACH GROUP CLASSIFICATION\n",
    "group_num_days[0] = 0                       ##### SETS FIRST INDEX TO ZERO BECAUSE THE 1ST GROUP ONLY CAME ONCE\n",
    "initial_month = 0                           ##### USED TO RESET THE MONTH DATE TO THE 1ST OF EVERY MONTH\n",
    "for cust_per_day in first_timers_monthly:    ##### ITERATING THROUGH LIST OF # OF CUSTOMERS PER MONTH\n",
    "    cust_group_ctr[0] = (cust_per_day*group_1_percent_month[current_month]) ### NUMBER OF PEOPLE IN GROUP 1 CLASSIFICATION/MONTHLY\n",
    "    cust_group_ctr[1] = (cust_per_day*group_2_percent_month[current_month]) ### NUMBER OF PEOPLE IN GROUP 2 CLASSIFICATION/MONTHLY\n",
    "    cust_group_ctr[2] = (cust_per_day*group_3_percent_month[current_month]) ### NUMBER OF PEOPLE IN GROUP 3 CLASSIFICATION/MONTHLY\n",
    "    cust_group_ctr[3] = (cust_per_day*group_4_percent_month[current_month]) ### NUMBER OF PEOPLE IN GROUP 4 CLASSIFICATION/MONTHLY\n",
    "    group_num_days[1] = (group_2_avg_days_month[current_month]) #### AVERAGE DAYS BETWEEN GROUP 2 CLASSIFICATION/MONTHLY\n",
    "    group_num_days[2] = (group_3_avg_days_month[current_month]) #### AVERAGE DAYS BETWEEN GROUP 3 CLASSIFICATION/MONTHLY\n",
    "    group_num_days[3] = (group_4_avg_days_month[current_month]) #### AVERAGE DAYS BETWEEN GROUP 4 CLASSIFICATION/MONTHLY\n",
    "    group_num_classes[3] =  (group_4_avg_classes_month[current_month])   #### AVERAGE NUMBER OF 4+ CLASSES FOR THAT MONTHLY CLASSIFICATION\n",
    "    for y in range(0,4):\n",
    "        ####### CHANGE 'int' TO 'math.ceil' IF PROJECTIONS ARE LOW #######  \n",
    "        for z in range(1, math.ceil(cust_group_ctr[y])+1):                          #### LOOPS THROUGH THE NUMBER OF CUSTOMERS IN THAT GROUP CLASSIFICATION\n",
    "            ####### CHANGE 'int' TO 'math.ceil' IF PROJECTIONS ARE LOW #######  \n",
    "            for j in range(int(group_num_classes[y])):                        #### LOOPS THROUGH THE CURRENT CLASSES EX. 4+ CLASSES FOR AJ'S CLASS IN JANUARY 2018\n",
    "                new_date = (start_date+timedelta(days=math.ceil(group_num_days[y])*j))        #### GENERATES DATES FOR CUSTOMERS DEPENDING ON THE GROUP \n",
    "                date_array_month.append(new_date)                                             #### ADDS NEW DATE TO date_array_monthly\n",
    "    current_month+=1                                          #### INCREMENTS CURRENT MONTH TO UPDATE THE MONTHLY STATS\n",
    "    if (initial_month==0):\n",
    "        start_date = start_date - timedelta(days=9)    ##### RESETS DATE TO THE 1ST OF EVERY MONTH\n",
    "    initial_month = 1\n",
    "    start_date = start_date + relativedelta(months=1)    #### UPDATES THE DATE TO ACCOMODATE FOR THE NEXT MONTH"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "############################################################\n",
    "# SORTS THE GENERATED DATES\n",
    "# DON'T NEED TO EDIT THIS CODE BLOCK\n",
    "############################################################\n",
    "date_array_filter.sort()\n",
    "date_array_month.sort()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "############################################################\n",
    "# GENERATES THE ARRAY OF MONTHS-YEAR FOR THE EXCEL EXPORT\n",
    "# DON'T NEED TO EDIT THIS CODE BLOCK\n",
    "############################################################\n",
    "date = datetime.datetime.strptime('2018-7-10', '%Y-%m-%d')\n",
    "month_labels = []\n",
    "current_month_index=0\n",
    "while (current_month_index<=len(actual_monthly_count)-1):       #### LOOPS THROUGH THE NUMBER OF MONTHS THE REGION HAS BEEN OPEN\n",
    "    current_month_index+=1    \n",
    "    month_labels.append(str(date.strftime(\"%B\") + ' ' + str(date.year)))       #### ADDS THE LABEL FOR THE MONTH-YEAR FORMAT\n",
    "    date = (date+relativedelta(months=1))   #### UPDATES TO DATE TO THE NEXT MONTH"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "############################################################\n",
    "# GENERATES THE ARRAY OF MONTHS-YEAR FOR THE EXCEL EXPORT\n",
    "# THESE ARE DATES GENERATED BY MONTHLY-FILTER STATS\n",
    "# DON'T NEED TO EDIT THIS CODE BLOCK\n",
    "############################################################\n",
    "index=0\n",
    "month_index=0\n",
    "month_cust_count=0\n",
    "filter_projected_count = []\n",
    "while(index<len(date_array_filter)-1):\n",
    "    while(date_array_filter[index].day==date_array_filter[index+1].day): \n",
    "        index+=1\n",
    "        if (index+1>=len(date_array_filter)-1):\n",
    "            break\n",
    "    month_cust_count = month_cust_count + date_array_filter.count(date_array_filter[index])\n",
    "    if (index+1>=len(date_array_filter)-1):\n",
    "            filter_projected_count.append(month_cust_count)\n",
    "            break\n",
    "    if(date_array_filter[index].month!=date_array_filter[index+1].month):\n",
    "################# THIS CODE BLOCK IS USED FOR MONTHLY HOLIDAY ADJUSTMENTS #################\n",
    "        if (date_array_filter[index].month==1): ###### IF THE MONTH IS JAN, MULT CUST COUNT BY 1.2\n",
    "            month_cust_count=month_cust_count*1.2\n",
    "        elif (date_array_filter[index].month==12):   ###### IF THE MONTH IS DECEMBER, MULT CUST COUNT BY .85\n",
    "            month_cust_count=month_cust_count*.85\n",
    "        elif (date_array_filter[index].month==7):   ###### IF THE MONTH IS JULY, MULT CUST COUNT BY .9\n",
    "            month_cust_count=month_cust_count*.9\n",
    "        elif (date_array_filter[index].month==11): ###### IF THE MONTH IS NOVEMBER, MULT CUST COUNT BY .9\n",
    "            month_cust_count=month_cust_count*.9\n",
    "#####################################################################################\n",
    "        filter_projected_count.append(month_cust_count)\n",
    "        month_cust_count=0\n",
    "    index+=1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "############################################################\n",
    "# GENERATES THE ARRAY OF MONTHS-YEAR FOR THE EXCEL EXPORT\n",
    "# THESE ARE DATES GENERATED BY MONTHLY STATS\n",
    "# DON'T NEED TO EDIT THIS CODE BLOCK\n",
    "############################################################\n",
    "index=0\n",
    "month_index=0\n",
    "month_cust_count=0\n",
    "monthly_projected_count = []\n",
    "while(index<len(date_array_month)-1):\n",
    "    while(date_array_month[index].day==date_array_month[index+1].day): \n",
    "        index+=1\n",
    "        if (index+1>=len(date_array_month)-1):\n",
    "            break\n",
    "    month_cust_count = month_cust_count + date_array_month.count(date_array_month[index])\n",
    "    if (index+1>=len(date_array_month)-1):\n",
    "        monthly_projected_count.append(month_cust_count)\n",
    "        break\n",
    "    if(date_array_month[index].month!=date_array_month[index+1].month):\n",
    "################# THIS CODE BLOCK IS USED FOR MONTHLY HOLIDAY ADJUSTMENTS #################\n",
    "        if (date_array_month[index].month==1): ###### IF THE MONTH IS JAN, MULT CUST COUNT BY 1.2\n",
    "            month_cust_count=month_cust_count*1.2\n",
    "        elif (date_array_month[index].month==12):   ###### IF THE MONTH IS DECEMBER, MULT CUST COUNT BY .85\n",
    "            month_cust_count=month_cust_count*.85\n",
    "        elif (date_array_month[index].month==7):   ###### IF THE MONTH IS JULY, MULT CUST COUNT BY .9\n",
    "            month_cust_count=month_cust_count*.9\n",
    "        elif (date_array_month[index].month==11): ###### IF THE MONTH IS NOVEMBER, MULT CUST COUNT BY .9\n",
    "            month_cust_count=month_cust_count*.9\n",
    "#####################################################################################\n",
    "        monthly_projected_count.append(month_cust_count)\n",
    "        month_cust_count=0\n",
    "    index+=1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "############################################################\n",
    "# ADDS ON MONTHS TO THE TOTAL MONTH COUNT TO MATCH THE  MONTHLY \n",
    "# PROJECTED COUNT OR THE FILTER PROJECTED COUNT \n",
    "# THIS IS ESSENTIAL FOR GRAPHING\n",
    "# DON'T NEED TO EDIT THIS CODE BLOCK\n",
    "############################################################\n",
    "if (len(monthly_projected_count)<len(filter_projected_count)):\n",
    "    total_months_tracker = len(filter_projected_count)\n",
    "    flag = 0\n",
    "else:\n",
    "    total_months_tracker = len(monthly_projected_count)   \n",
    "    flag = 1\n",
    "while (total_months_tracker>len(actual_monthly_count)):\n",
    "    actual_monthly_count.append(0)                         ### WILL ADD ON ZEROS IF EITHER STAT PROJECTS FURTHER THAN THE OTHER\n",
    "    if (flag==0):\n",
    "        if (len(monthly_projected_count)<total_months_tracker):\n",
    "            monthly_projected_count.append(0)\n",
    "    else:\n",
    "        if (len(filter_projected_count)<total_months_tracker):\n",
    "            filter_projected_count.append(0)\n",
    "    month_labels.append(str(date.strftime(\"%B\") + ' ' + str(date.year)))      ##### INCREMENTS MONTH\n",
    "    date = (date+relativedelta(months=1))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "############################################################\n",
    "# CREATES DATAFRAME OF THE PROJECTED MONTHLY COUNT VS ACTUAL MONTHLY COUNT\n",
    "# USED TO EXPORT TO EXCEL SHEET\n",
    "# DON'T NEED TO EDIT THIS CODE BLOCK\n",
    "############################################################\n",
    "dataFrame_month = pd.DataFrame({      \n",
    "    \"Months\":month_labels,                             ##### NAME OF EACH MONTH(FOR EASY VIEWING)\n",
    "    \"Monthly Projected Count\":monthly_projected_count,  ##### MONTHLY COUNT FROM THE MONTHLY STATS \n",
    "    la_filter + \" Projected Count\" : filter_projected_count,   ##### MONTHLY COUNT FROM THE MONTHLY-FILTER STATS \n",
    "    'Actual Monthly Count': actual_monthly_count           ##### ACTUAL MONTHLY COUNT OF THE DATASET\n",
    "    })"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "############################################################\n",
    "# DISPLAYS THE TOTAL NUMBER OF DATES FOR COMPARISON\n",
    "############################################################\n",
    "print(\"PROJECTED TOTAL MONTHLY ATTENDANCE:\" , sum(monthly_projected_count))\n",
    "print(\"\")\n",
    "print(\"PROJECTED TOTAL \" + la_filter + \" ATTENDANCE:\" , sum(filter_projected_count))\n",
    "print(\"\")\n",
    "print(\"ACTUAL NUMBER OF ATTENDANCE:\" , sum(actual_monthly_count))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "############################################################\n",
    "# DISPLAYS MONTHLY COMPARISONS\n",
    "############################################################\n",
    "dataFrame_month"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "############################################################\n",
    "# DISPLAYS GRAPH FOR VIEWING\n",
    "# THE VERTICAL LINE IS THE LAST RECORDED **FULL** MONTH\n",
    "############################################################\n",
    "graph = dataFrame_month.plot.line(figsize=(23, 7),style='.-',marker='o')\n",
    "plt.xlabel(\"Months\",size = 20)\n",
    "plt.ylabel(\"Customer Count\",size = 20)\n",
    "plt.title('Monthly Customer Count', size = 20)\n",
    "plt.xticks(size = 15)\n",
    "plt.yticks(size = 15)\n",
    "plt.axvline(x=last_full_month, color = 'c', linestyle = '--')\n",
    "graph.legend(fontsize=17,loc='best')\n",
    "plt.grid(True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "############################################################\n",
    "# CREATES EXCEL EXPORT CALLED LA-PROJECTIONS(*FILTER*)\n",
    "############################################################\n",
    "month_stats = pd.DataFrame({\"Months\":month_labels,\"Monthly Count\":monthly_projected_count,\n",
    "la_filter + \" Count\":filter_projected_count,\"Actual\":actual_monthly_count})\n",
    "\n",
    "# Create a Pandas Excel writer using XlsxWriter as the engine.\n",
    "if (paid==1):\n",
    "    writer = pd.ExcelWriter('LA-Projections-' + la_filter+ '(PAID).xlsx', engine='xlsxwriter')\n",
    "else:\n",
    "    writer = pd.ExcelWriter('LA-Projections-' + la_filter+ '(TOTAL).xlsx', engine='xlsxwriter')\n",
    "\n",
    "\n",
    "# Write each dataframe to a different worksheet.\n",
    "month_stats.to_excel(writer, sheet_name='Monthly')\n",
    "\n",
    "\n",
    "# Close the Pandas Excel writer and output the Excel file.\n",
    "writer.save()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
